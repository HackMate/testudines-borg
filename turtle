os.loadAPI("apis/network")
os.loadAPI("apis/miner")
os.loadAPI("apis/navigation")
os.loadAPI("/apis/tasks")
os.loadAPI("/apis/cclog")

local logger = cclog.Logger:create("WireLessCommandReceiver")

function WireLessCommandReceiver(network, taskRunner)
    local self = {}
    local network = network
    local taskRunner = taskRunner

    local function receiveOrder()
        logger:info("Awaiting orders")
        local id, orderName = network.receive(10)
        if miner.orders[orderName] then
            logger:info("Received order")
            return miner.orders[orderName], id, orderName
        end
    end

    function self.run()
        logger:info("started")

        repeat
            local newOrder, commanderId, command = receiveOrder()

            if newOrder then
                taskRunner.terminateCurrentTask()
                taskRunner.schedule(function() newOrder(commanderId, command) end)
            end

        until command == "reboot"

        logger:info("going down")
    end

    return self
end

local function create(first, ...)
    if first ~= nil then
        if type(first) ~= "function" then
            error("Expected function, got" .. type(first), 3)
        end
        return coroutine.create(first), create(...)
    end
    return nil
end

local function runtUntilLimit( _routines)
    local count = #_routines
    local living = count

    local tFilters = {}
    local eventData = {}
    while true do
        local reboot = eventData[1] == "rednet_message" and eventData[3] == "reboot"
        if reboot then
            network.send(eventData[2], "Forcing shutdown")
            eventData = {"terminate"}
        end

        for n=1,count do
            local r = _routines[n]
            if r then
                if tFilters[r] == nil or tFilters[r] == eventData[1] or eventData[1] == "terminate" then

                    local ok, param = coroutine.resume(r, table.unpack(eventData))
                    if not ok and not reboot then
                        error(param, 0)
                    else
                        tFilters[r] = param
                    end
                    if coroutine.status(r) == "dead" then
                        _routines[n] = nil
                        living = living - 1
                        if living <= 0 then
                            return n
                        end
                    end
                end
            end
        end

        eventData = {os.pullEventRaw()}
    end
end

function waitForAll( ... )
    local routines = { create( ... ) }
    runtUntilLimit(routines)
end

-- main --

network.init()
navigation.init(network)
miner.init(navigation)

taskRunner = tasks.SerialTaskRunner()
commandReceiver = WireLessCommandReceiver(network, taskRunner)

waitForAll(function() commandReceiver.run() end, function() taskRunner.run() end)

print("rebooting")
os.reboot()