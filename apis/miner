os.loadAPI("/apis/utils")

-- Navigator interface --
navigator = {}
function navigator.hasHome() error("hasHome must be implemented") end
function navigator.isHome() error("isHome must be implemented")end
function navigator.findHome() error("findHome must be implemented")end
function navigator.goHome() error("goHome must be implemented")end
function navigator.getFuel() error("getFuel must be implemented")end
function navigator.distanceToHome() error("distanceToHome must be implemented") end
function navigator.getPosition() error("getPosition must be implemented") end
function navigator.getHomePosition() error("getHomePosition must be implemented") end
function navigator.clearHome() error("clearHome must be implemented") end

local state = {
       currentOrder = nil,
       queuedOrders = {},
       fuel = {level = 0, inSlot = nil}
    }

local orders = {}
function orders.refuel(commanderId, message)
    if needsFuel() then
        print("Miner: I need fuel")
        if hasFuel() then
            print("Miner: I have fuel")
            if useFuel() then
                network.send(commanderId, "Miner: I used my fuel")
            end
        end
        if needsFuel() then
            network.send(commanderId, "Miner: I don't have fuel, going home.")
            navigator.goHome()
            if navigator.getFuel() and hasFuel() then
                useFuel()
            else
                -- Order did not finish.
                return false
            end
        end
    else
        local message = "Miner: I do not need to refuel fuelLevel: " .. turtle.getFuelLevel() ..
                " distanceToHome: " .. navigator.distanceToHome()
        print(message)
        network.send(commanderId, message)
    end
end
function orders.fuelLevel(commanderId)
    network.send(commanderId, "Miner: fuelLevel: " .. turtle.getFuelLevel())
end
function orders.distanceToHome(commanderId)
    network.send(commanderId, "Miner: distanceToHome: " .. navigator.distanceToHome())
end
function orders.clearHome(commanderId)
    local success, message = navigator.clearHome()
    if success then
        network.send(commanderId, "Miner: cleared home")
    else
        network.send(commanderId, "Miner: could not clear home" .. message)
    end
end
function orders.hasHome(commanderId)
    if navigator.hasHome() then
        network.send(commanderId, "Miner: has a home at " .. navigator.getHomePosition():tostring())
    else
        network.send(commanderId, "Miner: has no home")
    end
end
function orders.findHome(commanderId)
    network.send(commanderId, "Miner: will find a new home")
    navigator.findHome()
    network.send(commanderId, "Miner: has a home at " .. navigator.getHomePosition():tostring())
end
function orders.homePosition(commanderId)
    network.send(commanderId, "Miner: homePosition: " .. navigator.getHomePosition():tostring())
end
function orders.position(commanderId)
    network.send(commanderId, "Miner: position: " .. navigator.getPosition():tostring())
end
function orders.shutdown(commanderId, _)
    print("Miner: shutdown")
    network.send(commanderId, "Miner: shutting down")
end
function orders.dance(commanderId)
    if needsFuel() then
        print("Miner: need-fuel, cannot dance without some juice")
        network.send(commanderId, "Miner: need-fuel, cannot dance without some juice")
        return true
    end
    print("Miner: let's dance")
    network.send(commanderId, "Miner: will dance")
    turtle.forward()
    turtle.forward()
    for i=1,2,1 do
        makeAmove(turtle.up)
        makeAmove(turtle.up)
        makeAmove(turtle.forward)
        makeAmove(turtle.down)
        makeAmove(turtle.turnRight)
        makeAmove(turtle.forward)
        makeAmove(turtle.back)

        makeAmove(turtle.turnLeft)
        makeAmove(turtle.turnLeft)

        makeAmove(turtle.forward)
        makeAmove(turtle.back)
        makeAmove(turtle.turnRight)
        makeAmove(turtle.down)
        makeAmove(turtle.back)
    end
    makeAmove(turtle.back)
    makeAmove(turtle.back)
    return false
end

function makeAmove(move, retries)
    if retries and retries < 1 then
        error("Miner: cannot move")
    end
    if not move() then
        os.sleep(0.2)
        if not retries then
            retries = 20
        end
        turtle.attack()
        makeAmove(move, retries-1)
    end
end

function receiveOrder()
    print("Miner: Awaiting orders")
    local id, orderName = network.receive(10)
    if orders[orderName] then
        print("Miner: Received orders")
        return orders[orderName], id, orderName
    end
end

function needsFuel()
    state.fuel.level = turtle.getFuelLevel()
    local distanceToHome = navigator.distanceToHome()
    print("Miner: I have ", state.fuel.level, " and have distance to home of ", distanceToHome)
    return state.fuel.level < distanceToHome * 2 or distanceToHome == 0 and state.fuel.level < 100
end

function hasFuel()
    local slot = 0
    repeat
        slot = slot+1
        local success, _ = pcall(function() turtle.select(slot) end)
        if success then
            local details = turtle.getItemDetail()
            if utils.isFuel(details) then
                print("Miner: I have fuel " .. details.name)
                state.fuel.inSlot = slot
                return true, details.name
            end
        end
    until success == false

    return false
end

function useFuel(slot)
    if slot then
        state.fuel.inSlot = slot
    end
    if state.fuel.inSlot then
        turtle.select(state.fuel.inSlot)
        return turtle.refuel()
    else
        return false
    end
end

function init(navigationController)
    for field, _ in pairs(navigator) do
        if not navigationController[field] then
            error("navigator must implement field: " .. field .. " of type (" .. type(navigator[field]) .. ")")
        end
    end

    navigator = navigationController
end

function run()
    print("Miner: started")

    if not navigator.hasHome() then
        navigator.findHome()
    end

    repeat
        local newOrder, commanderId, command = receiveOrder()

        local success, message = pcall(function()
            if newOrder then
                state.currentOrder = newOrder
            end
            if state.currentOrder then
                if not newOrder then
                    print("Miner: Resuming current order")
                end
                if state.currentOrder(commanderId, command) == false then
                    print("Miner: order has not been finished, resuming later")
                else
                    print("Miner: order has been finished")
                    state.currentOrder = nil
                end
            end
        end)
        if not success then
            state.currentOrder = nil
            message = "Miner: failed to execute order: " .. message
            print(message)
            network.send(commanderId, message)
        end
    until command == "shutdown"

    print("Miner: done")
end