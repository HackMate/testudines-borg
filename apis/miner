os.loadAPI("/apis/utils")
os.loadAPI("/apis/cclog")
os.loadAPI("/apis/drone")

local logger = cclog.Logger:create("Miner")

-- Navigator interface --
navigator = {}
function navigator.hasHome() error("hasHome must be implemented") end
function navigator.isHome() error("isHome must be implemented")end
function navigator.findHome() error("findHome must be implemented")end
function navigator.goHome() error("goHome must be implemented")end
function navigator.getFuel() error("getFuel must be implemented")end
function navigator.distanceToHome() error("distanceToHome must be implemented") end
function navigator.getPosition() error("getPosition must be implemented") end
function navigator.getHomePosition() error("getHomePosition must be implemented") end
function navigator.clearHome() error("clearHome must be implemented") end

local drone = drone.Drone()

local state = {
       currentOrder = nil,
       queuedOrders = {},
       fuel = {level = 0, inSlot = nil}
    }

orders = {}
function orders.refuel(commanderId, message)
    if needsFuel() then
        print("I need fuel")
        if hasFuel() then
            logger:info("I have fuel")
            if useFuel() then
                network.send(commanderId, "I used my fuel")
            end
        end
        if needsFuel() then
            network.send(commanderId, "I don't have fuel, going home.")
            navigator.goHome()
            if navigator.getFuel() and hasFuel() then
                useFuel()
            else
                -- Order did not finish.
                return false
            end
        end
    else
        local message = "I do not need to refuel fuelLevel: " .. drone.getFuelLevel() ..
                " distanceToHome: " .. navigator.distanceToHome()
        print(message)
        network.send(commanderId, message)
    end
end
function orders.fuelLevel(commanderId)
    network.send(commanderId, "fuelLevel: " .. drone.getFuelLevel())
end
function orders.distanceToHome(commanderId)
    network.send(commanderId, "distanceToHome: " .. navigator.distanceToHome())
end
function orders.clearHome(commanderId)
    local success, message = navigator.clearHome()
    if success then
        network.send(commanderId, "cleared home")
    else
        network.send(commanderId, "could not clear home" .. message)
    end
end
function orders.hasHome(commanderId)
    if navigator.hasHome() then
        network.send(commanderId, "has a home at " .. navigator.getHomePosition():tostring())
    else
        network.send(commanderId, "has no home")
    end
end
function orders.findHome(commanderId)
    network.send(commanderId, "will find a new home")
    navigator.findHome()
    network.send(commanderId, "has a home at " .. navigator.getHomePosition():tostring())
end
function orders.homePosition(commanderId)
    network.send(commanderId, "homePosition: " .. navigator.getHomePosition():tostring())
end
function orders.position(commanderId)
    network.send(commanderId, "position: " .. navigator.getPosition():tostring())
end
function orders.reboot(commanderId, _)
    logger:info("reboot")
    network.send(commanderId, "rebooting now")
    network.closeConnection()
end
function orders.dance(commanderId)
    if needsFuel() then
        logger:info("need-fuel, cannot dance without some juice")
        network.send(commanderId, "need-fuel, cannot dance without some juice")
        return true
    elseif not navigator.hasHome() then
        logger:info("don't have a home")
        network.send(commanderId, "don't have a home")
        return true
    end
    logger:info("let's dance")
    network.send(commanderId, "will dance")
    drone.forward()
    drone.forward()
    for i=1,2,1 do
        makeAmove(drone.up)
        makeAmove(drone.up)
        makeAmove(drone.forward)
        makeAmove(drone.down)
        makeAmove(drone.turnRight)
        makeAmove(drone.forward)
        makeAmove(drone.back)

        makeAmove(drone.turnLeft)
        makeAmove(drone.turnLeft)

        makeAmove(drone.forward)
        makeAmove(drone.back)
        makeAmove(drone.turnRight)
        makeAmove(drone.down)
        makeAmove(drone.back)
    end
    makeAmove(drone.back)
    makeAmove(drone.back)

    return false
end
function orders.ping(commanderId)
    logger:info("sending pong")
    network.send(commanderId, "pong")
end

function makeAmove(move, retries)
    if retries and retries < 1 then
        error("cannot move")
    end
    if move() then
        return true
    else -- Try again --
        os.sleep(0.2)
        drone.attack()
        return makeAmove(move, retries and retries-1 or 20)
    end
end

function needsFuel()
    state.fuel.level = drone.getFuelLevel()
    local distanceToHome = navigator.distanceToHome()
    logger:info("I have %s and have a distance to home of %s", state.fuel.level, distanceToHome)
    return state.fuel.level < distanceToHome * 2 or distanceToHome == 0 and state.fuel.level < 100
end

function hasFuel()
    local slot = 0
    repeat
        slot = slot+1
        local success, _ = pcall(function() drone.select(slot) end)
        if success then
            local details = drone.getItemDetail()
            if utils.isFuel(details) then
                logger:info("I have fuel %s", details.name)
                state.fuel.inSlot = slot
                return true, details.name
            end
        end
    until success == false

    return false
end

function useFuel(slot)
    if slot then
        state.fuel.inSlot = slot
    end
    if state.fuel.inSlot then
        drone.select(state.fuel.inSlot)
        return drone.refuel()
    else
        return false
    end
end

function init(navigationController)
    for field, _ in pairs(navigator) do
        if not navigationController[field] then
            error("navigator must implement field: " .. field .. " of type (" .. type(navigator[field]) .. ")")
        end
    end

    navigator = navigationController
end
