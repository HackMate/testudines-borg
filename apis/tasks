os.loadAPI("/apis/cclog")

local logger = cclog.Logger("SerialTaskRunner")

function TaskQueue()
    local self = {}
    local first = 0
    local last = -1

    function self.pushleft (value)
        first = first - 1
        self[first] = value
    end

    function self.pushright (value)
        last = last + 1
        self[last] = value
    end

    function self.popleft ()
        if first > last then error("task queue is empty") end
        local value = self[first]
        self[first] = nil        -- to allow garbage collection
        first = first + 1
        return value
    end

    function self.popright ()
        if first > last then error("task queue is empty") end
        local value = self[last]
        self[last] = nil         -- to allow garbage collection
        last = last - 1
        return value
    end

    function self.isempty()
        return first == last + 1
    end

    return self
end

function SerialTaskRunner()
    local self = {}

    local taskQueue = TaskQueue()
    local currentTask
    local currentFilter
    local abortTask = false

    function self.run()
        local eventData = {}
        repeat

            if currentTask == nil and not taskQueue.isempty() then
                logger.info("setting current task")
                currentTask = taskQueue.popright()
            end

            if currentTask ~= nil and abortTask == true  then
                logger.info("Terminating current task")
                abortTask = false
                eventData = {"terminate"}
            end

            if currentTask ~= nil and (
                    currentFilter == nil or
                    currentFilter == eventData[1] or
                    eventData[1] == "terminate") then
                logger.info("Resuming task")
                local ok, param = coroutine.resume(currentTask, table.unpack(eventData))
                if not ok then
                    logger.info("task failed ", currentTask, param)
                else
                    currentFilter = param
                end

                if coroutine.status(currentTask) == "dead" then
                    logger.info("task ended ", currentTask)
                    currentTask = nil
                    currentFilter = nil
                end

            end
            logger.debug("yielding")
            eventData = {coroutine.yield()}
            logger.debug("resuming", table.unpack(eventData))
        until eventData[1] == "reboot" or eventData[1] == "terminate"

        logger.info("Going down")
    end

    function self.schedule(task)
        if type(task) ~= "function" then
            error("Expected function, got" .. type(task), 3)
        end
        local routine = coroutine.create(task)
        logger.info("Scheduling task", routine)
        taskQueue.pushleft(routine)
    end

    function self.terminateCurrentTask()
        abortTask = true
    end

    return self
end
