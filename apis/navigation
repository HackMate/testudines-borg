os.loadAPI("/apis/model/position")
os.loadAPI("/apis/utils")
os.loadAPI("/apis/cclog")
os.loadAPI("/apis/ccoop")
os.loadAPI("/apis/model/queue")

local logger = cclog.Logger("Navigation")

function HomeNavigator(network, drone, fileSystem)
    local self = {}

    local network = network
    local logger = cclog.Logger("HomeNavigator")

    local state = {
        file = ".navigation-home",
        home = {
            pos = nil
        }
    }

    function self.loadState()
        local success, result = utils.loadTable(state.file, fileSystem)
        if success then
            state = result
            logger.info("loaded home position %s", state.home.pos.tostring())
        else
            state.home.pos = nil
            logger.error("could not deserialize home position %s", result)
        end
    end

    function self.saveState()
        local success, message = utils.saveTable(state.file, state, fileSystem)
        if not success then
            logger.warn("Could not save state '" .. message .. "'")
        end
    end

    function self.turnAround()
        drone.turnRight()
        drone.turnRight()
    end

    function self.turnTowardsChest()
        while not self.seesAChest() do
            os.sleep(2)
            drone.turnLeft()
            logger.info("I am looking for a chest")
        end
        return true
    end

    function self.seesAChest()
        local success, details = drone.inspect()
        if success then
            if string.match(string.lower(details.name), "chest") then
                logger.info("found a chest" .. details.name)
                return true, details.name
            end
        end
        return false
    end

    local isNeeded = {}
    isNeeded["minecraft:torch"] = 64
    function self.needItem(detail)
        return detail and self.isNeeded[detail.name]
    end

    function self.takeFuelFromChest()
        local hasTakenFuel = false
        for i=1,16,1 do
            if not self.needItem(drone.getItemDetail(i)) then
                drone.select(i);drone.drop()
                drone.suck()
                if utils.isFuel(drone.getItemDetail(i)) then
                    hasTakenFuel = true
                end
            end
        end
        -- put everything back that are is not needed
        for i=1,16,1 do
            local details = drone.getItemDetail(i)
            if not self.needItem(details) and not utils.isFuel(details) then
                drone.select(i);drone.drop()
            end
        end
        return hasTakenFuel
    end

    function self.getFuel()
        if self.isHome() and self.turnTowardsChest() and self.takeFuelFromChest() then
            logger.info("Navigation: found fuel")
            self.turnAround()
            return true
        else
            logger.info("Navigation: cannot get fuel")
            self.turnAround()
            return false
        end
    end

    function self.findHome()
        logger.info("I need a chest to make this my home")
        self.turnTowardsChest()
        self.turnAround()

        logger.info("I like this place")
        local pos = network.getGpsLocation()
        self.setHome(pos)
        drone.setPosition(pos)
    end

    function self.setHome(pos)
        if pos and pos.isValid() then
            logger.info("Navigator: Setting home position " .. pos.tostring())
            state.home.pos = pos
            self.saveState()
        else
            error("setHome needs a valid position")
        end
    end

    function self.hasHome()
        return state.home.pos ~= nil
    end

    function self.distanceToHome()
        return position.distance(network.getGpsLocation(), state.home.pos)
    end

    function self.clearHome()
        state.home.pos = nil
        self.saveState()
        return true
    end

    function self.getHomePosition()
        if state.home.pos then
            return state.home.pos
        else
            return position.Position()
        end
    end

    function self.isHome()
        return state.home.pos == network.getGpsLocation()
    end

    self.loadState()

    return self
end

function Navigator(network, drone)
    local _homeNavigator = HomeNavigator(network, drone, fs)
    local self, super = extend(_homeNavigator)
    local logger = cclog.Logger("Navigation")

    function self.getPosition()
        return network.getGpsLocation()
    end

    function self.goHome()
        if self.isHome() then
            return true
        else
            logger.info("Navigation: I do not know how to get home")
            return false
        end
    end

    local function getNeighbours(pos, goal)
        local neighbours = {
            position.Position(pos.x, pos.y, pos.z - 1, position.North), -- North
            position.Position(pos.x, pos.y, pos.z + 1, position.South), -- South
            position.Position(pos.x + 1, pos.y, pos.z, position.East), -- East
            position.Position(pos.x - 1, pos.y, pos.z, position.West), -- West
            position.Position(pos.x, pos.y + 1, pos.z), -- Up
            position.Position(pos.x, pos.y - 1, pos.z)  -- Down
        }

        -- Sort according to distance to the goal plus a facing bonus if the turtle
        -- will not have to turn to face that position. (Less turns means more speed.)
        table.sort(neighbours, function(pos1, pos2)
            local dis1, dis2 = position.distance(pos1, goal), position.distance(pos2, goal)
            local function facingBonus(temp)
                if pos.facing ~= position.Unknown and temp.facing == pos.facing then
                    return -1
                end
                return 0
            end
            return dis1 + facingBonus(pos1) < dis2 + facingBonus(pos2)
        end)

        return neighbours
    end

    local function turnTowardPosition(pos)
        local currentPosition = drone.getPosition()
        local leftTurns, rightTurns = position.necessaryTurns(currentPosition, pos)
        if leftTurns < rightTurns then
            for _ = 1, leftTurns, 1 do
                logger.info("turning left")
                drone.turnLeft()
            end
        else
            for _ = 1, rightTurns, 1 do
                logger.info("turning right")
                drone.turnRight()
            end
        end
    end

    local function moveTo(pos)
        logger.info("movTo " .. pos.tostring())
        local currentPosition = drone.getPosition()
        if currentPosition == pos then
            return true
        else
            local hightLevel = currentPosition.y - pos.y
            local move, inspect
            if  hightLevel > 0 then
                inspect, move = drone.inspectDown, drone.down
            elseif hightLevel < 0 then
                inspect, move = drone.inspectUp, drone.up
            else
                turnTowardPosition(pos)
                inspect, move = drone.inspect, drone.forward
            end
            local blocked, message = inspect()
            return not blocked and move() or false, message

        end
    end

    local function positionKey(pos)
        if pos == nil then
            error("Cannot create a key for a nil value")
        end
        return string.format("%d,%d,%d", pos.x, pos.y, pos.z)
    end

    function self.goTo(goal)
        -- Pathfinding using a depth-first-search kind of approach until we hit the goal or fail.
        local current = drone.getPosition()
        local route = queue.Queue()
        if current == goal then
            logger.info("Already at pos: %s", current.tostring())
            return true, route
        end

        local visitedPositions = {}
        visitedPositions[positionKey(current)] = current
        local next
        repeat
            next = nil
            for _, neighbour in pairs(getNeighbours(drone.getPosition(), goal)) do
                local posKey = string.format("%d,%d,%d", neighbour.x, neighbour.y, neighbour.z)
                if visitedPositions[posKey] == nil then
                    next = neighbour
                    visitedPositions[positionKey(next)] = next
                    break
                end
            end

            if next ~= nil and moveTo(next) then
                logger.info("move was successful")
                route.pushleft(next)
                if next == goal then
                    logger.info("Arrived at pos: %s", next.tostring())
                    return true, route
                end
            elseif next == nil and not route.isempty() then
                logger.info("retracing step")
                local stepBack = route.popleft()
                local success, message = moveTo(stepBack)
                if success then
                    next = stepBack
                else
                    logger.error("Could not retracte steps %s", message)
                end
            end

        until next == nil

        logger.info("Did not find pos: %s", goal.tostring())
        return false
    end

    function self.calibrateFacing()
        logger.info("calibrating")
        local pos = self.getPosition()
        if pos.facing == position.Unknown and drone.forward() then
            local newPosition = self.getPosition()
            logger.info("old-positon: %s new-position: %s", pos.tostring(), newPosition.tostring())
            if newPosition and newPosition.isValid() then
                pos.setOrientation(newPosition)
            end
            drone.back()
            drone.setPosition(pos)
        end
    end

    function self.needsFuel()
        local distanceToHome = super.distanceToHome()
        local fuelLevel = drone.getFuelLevel()
        logger.info("I have %d fuel and have a distance to home of %s", fuelLevel, distanceToHome)
        return fuelLevel < distanceToHome * 2 or distanceToHome == 0 and fuelLevel < 100
    end


    return self
end